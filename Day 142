Day 142/150: Adjacent Increasing Subarrays Detection I

Problem Statement #3349

Problem Statement Explanation:

You are given an integer list nums and an integer k.
Your task is to determine whether there exist two adjacent strictly increasing subarrays, each of length at least k.


Formally, check if there exists an index i such that:

nums[i - k + 1] < nums[i - k + 2] < ... < nums[i], and
nums[i + 1] < nums[i + 2] < ... < nums[i + k].

If such adjacent increasing subarrays exist, return true; otherwise, return false.

Input:
nums = [1, 2, 3, 2, 3, 4], k = 2
Output:
true
Explanation:
The subarrays [1, 2, 3] and [2, 3, 4] are both strictly increasing, and the two increasing segments are adjacent.


Solution Approch:

Maintain two counters:

increasing → tracks the length of the current strictly increasing segment.
prevIncreasing → stores the length of the previous increasing segment before a drop or reset.

Iterate through the list:
If the current element is greater than the previous, increment increasing.
Otherwise, assign increasing to prevIncreasing and reset increasing to 1.
At every step, check two conditions:
Whether a single long increasing segment can be split into two adjacent parts of size ≥ k (increasing / 2 >= k).
Whether the tail of the previous segment and the head of the current one are both ≥ k (min(prevIncreasing, increasing) >= k).
If either condition holds, return true.
If no such pattern is found after the full iteration, return false.

Here's the code:

import java.util.List;

class Solution {
    public boolean hasIncreasingSubarrays(List<Integer> nums, int k) {
        int increasing = 1;
        int prevIncreasing = 0;
        for (int i = 1; i < nums.size(); ++i) {
            if (nums.get(i) > nums.get(i - 1)) {
                ++increasing;
            } else {
                prevIncreasing = increasing;
                increasing = 1;
            }
            if (increasing / 2 >= k || Math.min(prevIncreasing, increasing) >= k)
                return true;
        }
        return false;
    }
}

Complexity:

Time Complexity: O(n)
Space Complexity: O(1)




