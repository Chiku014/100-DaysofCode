Day 216/250: Meeting Rooms III

Problem Statement #2402

Problem Statement Explantion:

You are given an integer n. There are n rooms numbered from 0 to n - 1. 
You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). 
All the values of starti are unique.

Meetings are allocated to rooms in the following manner:
Each meeting will take place in the unused room with the lowest number.
If there are no available rooms, the meeting will be delayed until a room becomes free. 
The delayed meeting should have the same duration as the original meeting.
When a room becomes unused, meetings that were delayed should be given the room in the same order as they appeared in the input.
Return the number of the room that held the most meetings. 
If there are multiple rooms, return the room with the lowest number.

Solution Approach:

To efficiently simulate the room allocation, we use two Min-Heaps (Priority Queues):

availableRooms: A Min-Heap storing the indices of rooms currently not in use. 
This ensures we always pick the room with the lowest index first.
busyRooms: A Min-Heap storing [endTime, roomIndex] for meetings currently in progress. 
It is ordered by endTime (earliest finish first). If two meetings end at the same time, they are ordered by roomIndex.

Algorithm Steps:
Step 1: Sort the meetings array based on their start times.
Step 2: Iterate through each meeting:
Free Rooms: Before assigning the current meeting, check busyRooms. 
Any room whose endTime is less than or equal to the current meeting's start time is moved back to availableRooms.

Assign Room:
If availableRooms is not empty, take the smallest index, increment its meeting count, and push it to busyRooms with the meeting's original end time.
If all rooms are busy, find the room that finishes earliest from busyRooms. 
Delay the current meeting: its new end time becomes earliestFinishTime + duration.

Step 3: Count and Compare: Maintain an array to track how many meetings each room hosted. 
After processing all meetings, return the index of the room with the maximum count.

Here's the code:

import java.util.*;

class Solution {
    public int mostBooked(int n, int[][] meetings) {
        Arrays.sort(meetings, (a, b) -> Integer.compare(a[0], b[0]));

        PriorityQueue<Integer> availableRooms = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            availableRooms.offer(i);
        }

        PriorityQueue<long[]> busyRooms = new PriorityQueue<>((a, b) -> {
            if (a[0] != b[0]) return Long.compare(a[0], b[0]);
            return Long.compare(a[1], b[1]);
        });

        int[] meetingCount = new int[n];

        for (int[] meeting : meetings) {
            long start = meeting[0];
            long end = meeting[1];
            long duration = end - start;

            while (!busyRooms.isEmpty() && busyRooms.peek()[0] <= start) {
                availableRooms.offer((int) busyRooms.poll()[1]);
            }

            if (!availableRooms.isEmpty()) {
                int roomIdx = availableRooms.poll();
                meetingCount[roomIdx]++;
                busyRooms.offer(new long[]{end, (long) roomIdx});
            } else {
                long[] earliestRoom = busyRooms.poll();
                long newStartTime = earliestRoom[0];
                int roomIdx = (int) earliestRoom[1];
                
                meetingCount[roomIdx]++;
                busyRooms.offer(new long[]{newStartTime + duration, (long) roomIdx});
            }
        }

        int resultRoom = 0;
        for (int i = 1; i < n; i++) {
            if (meetingCount[i] > meetingCount[resultRoom]) {
                resultRoom = i;
            }
        }

        return resultRoom;
    }
}

Complexity:

Time Complexity: O(MlogM+MlogN)
Space Complexity: O(N)





