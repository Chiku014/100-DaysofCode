Day 184/200: Smallest Integer Divisible by K

Problem Statement #1015

Problem Statement Explanation:

Given a positive integer k, you need to find the length of the smallest positive integer n consisting only of the digit 1 that is divisible by k.
Return the length of n. If there is no such n, return -1.
Note: n may not fit in a 64-bit signed integer.

Solution Approch:

1. Pattern Recognition: We are looking for numbers in the sequence: 1, 11, 111, 1111, 11111, ...
2. Mathematical Property: Any number consisting only of 1s can be represented as:
   - 1 = 1
   - 11 = 10 + 1
   - 111 = 100 + 10 + 1
   - This forms a repunit: (10^n - 1) / 9

3. Divisibility by 2 or 5: Numbers made of only 1s are always odd and never end in 0 or 5, so they can never be divisible by 2 or 5. We can immediately return -1 for such cases.
4. Modular Arithmetic: Instead of constructing massive numbers (which may exceed integer limits), we use modular arithmetic to track only the remainder.

Algorithm:

1. Early termination: If k is divisible by 2 or 5, return -1.

2. Iterative construction: 
   - Start with remainder = 0
   - For each length from 1 to k:
     - Calculate remainder = (remainder * 10 + 1) % k
     - This simulates appending a 1 digit
     - If remainder == 0, we found our answer


3. Cycle detection: 
   - By the Pigeonhole Principle, there are only k possible remainders (0 to k-1)
   - If we iterate k times without finding a solution, we must have encountered a cycle
   - This means no solution exists

Here's the code:

class Solution {
    public int smallestRepunitDivByK(int k) {
        if (k % 2 == 0 || k % 5 == 0) {
            return -1;
        }

        int remainder = 0;

        for (int length = 1; length <= k; length++) {
            remainder = (remainder * 10 + 1) % k;

            if (remainder == 0) {
                return length;
            }
        }

        return -1;
    }
}

Complexity:

Time Complexity: O(k)
Space Complexity: O(1)




