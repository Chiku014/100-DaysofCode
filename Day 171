Day 171/200:  Minimum Number of Operations to Make All Array Elements Equal to 1

Problem Statement #2654

Problem Statement Explanation:

Given an array of positive integers nums, you can perform an operation on any two adjacent elements nums[i] and nums[i+1].
In one operation, you can replace either nums[i] or nums[i+1] with their Greatest Common Divisor (GCD).
The goal is to find the minimum number of operations required to make all elements in the array equal to 1. If it's impossible, return -1.

Solution Approach:

The solution is based on analyzing three distinct scenarios, ordered from simplest to most complex.

Case 1: 
The array already contains at least one '1'
This is the simplest case. 
If the array already has one or more 1s, we don't need to create any. 
A 1 can "infect" its neighbors, since gcd(1, x) = 1 for any x.
We just need to count the number of non-1 elements. 
Each non-1 element will require one operation to be converted by an adjacent 1.

Example: [6, 2, 1, 4]
Count of 1s: 1
Count of non-1s: 3 (6, 2, 4)
Result: n - (count of 1s) = 4 - 1 = 3 operations.

Case 2: 
The array is impossible to solve
If there are no 1s, we must create one. 
A 1 can only be created if we find two numbers a and b (not necessarily adjacent) such that gcd(a, b) = 1.
If the GCD of the entire array is greater than 1 (e.g., [2, 4, 6, 8]), then any gcd(a, b) operation will also be a multiple of that overall GCD. 
We will always get an even number and can never create a 1.
We detect this case after checking Case 3. 
If we search for a subarray with gcd=1 and find none, it's impossible.

Result: Return -1

Case 3: No '1's exist, but a '1' can be created
This is the most complex scenario. 
The array contains no 1s, but the overall array's GCD is 1 (meaning it's possible to create a 1).

Our strategy is:
Find Cost to Create: Find the minimum operations to create the first 1.
Find Cost to Spread: Add the operations needed to spread that 1 to the rest of the array.
1. Cost to Create: To create a 1, we must find the shortest possible subarray [i...j] (of length k) whose gcd(nums[i]...nums[j]) = 1.
Why? It takes k - 1 operations to reduce a subarray of length k and gcd=1 to have a 1 at one of its positions.
Example: [2, 6, 3] (length k=3, gcd(2,6,3)=1)
[2, 6, 3] -> [2, gcd(6,3), 3] -> [2, 3, 3] (1 op)
[2, 3, 3] -> [gcd(2,3), 3, 3] -> [1, 3, 3] (2 ops)
It took k - 1 = 2 operations to create the first 1.
To find this, we use a nested loop. We iterate from i = 0 to n. For each i, we start an inner loop j = i+1 to n, calculating the gcd(nums[i]...nums[j]). 
The first time this gcd becomes 1, we record the subarray length k = (j - i + 1) and update our overall minK.

2. Cost to Spread: Once we have our first 1 (which took minK - 1 ops), we are back in a situation similar to Case 1. We have n elements, one of which is 1. 
We need n - 1 more operations to spread this 1 to the other n - 1 elements.
Result: Total Operations = (minK - 1) + (n - 1)

Here's the code:

class Solution {

    private int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    public int minOperations(int[] nums) {
        int n = nums.length;
        int ones = 0;

        for (int val : nums) {
            if (val == 1) {
                ones++;
            }
        }
        if (ones > 0) {
            return n - ones;
        }

        int minK = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int currentGcd = nums[i];
            for (int j = i + 1; j < n; j++) {
                currentGcd = gcd(currentGcd, nums[j]);
                if (currentGcd == 1) {
                    int k = (j - i) + 1;
                    minK = Math.min(minK, k);
                    break;
                }
            }
        }

        if (minK == Integer.MAX_VALUE) {
            return -1;
        }

        return (minK - 1) + (n - 1);
    }
}

Complexity:

Time Complexity: O(n^2)
Space Complexity: O(1)


