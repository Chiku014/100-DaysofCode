Day 66/100: Longest Subarray With Maximum Bitwise AND

Problem Statement #2941

Problem Statement Explanation:


The goal is to find a continuous part of an array (a "subarray") that meets two conditions:
Its "bitwise AND" value is the highest possible out of all subarrays.
It is the longest possible subarray that meets the first condition.
The most important insight is understanding the bitwise AND operation (&). 
The result of a & b can never be larger than either a or b. 
This means the bitwise AND of an entire subarray can never be larger than the maximum number found in that subarray.
Therefore, the maximum possible bitwise AND value you can get is simply the largest number in the entire input array.

Solution Approach:

The problem can be solved efficiently in a single pass through the array.
Identify the Target Value: The first step is to realize that the maximum possible bitwise AND is just the maximum element (max_val) in the array nums.
Find the Longest Streak: Now, the problem is simply to find the longest continuous subarray where every element is equal to max_val.

Single-Pass Algorithm:
Iterate through the array while keeping track of the max_val seen so far, the maxLength of a streak of that max value, and the currentLength of the current streak.
If you encounter a number greater than the current max_val, you've found a new maximum. 
The old streaks are now invalid. 
You must update max_val to this new number and reset both maxLength and currentLength to 1.
If you encounter a number equal to the current max_val, you are extending the current streak. 
Increment currentLength and update maxLength if the current streak is now the longest one found (maxLength = Math.max(maxLength, currentLength)).

If you encounter a number less than max_val, the streak is broken. Reset currentLength to 0.
By the end of the loop, maxLength will hold the length of the longest subarray with the maximum possible bitwise AND.

Here's the code:

class Solution {
    public int longestSubarray(int[] nums) {
        int maxVal = 0;
        int maxLength = 0;
        int currentLength = 0;

        for (int num : nums) {
            if (num > maxVal) {
                maxVal = num;
                maxLength = 1;
                currentLength = 1;
            } else if (num == maxVal) {
                currentLength++;
                maxLength = Math.max(maxLength, currentLength);
            } else {
                currentLength = 0;
            }
        }
        
        return maxLength;
    }
}

Coplexity:

Time Complexity: O(N)
Space Complexity: O(1)
