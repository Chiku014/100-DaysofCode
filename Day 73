Day 73/100: Fruits Into Baskets III

Problem Statement #3479

Problem Statement Explanation:

You are given two integer arrays, fruits1 and fruits2, representing fruits in two separate sets of baskets. 
The goal is to make the fruit composition of both sets identical by swapping fruits.
A swap is permitted between a fruit x from fruits1 and a fruit y from fruits2 if and only if x <= y.
Your task is to determine the minimum number of fruits that will remain unplaced after performing an optimal number of swaps. 
A fruit is considered "unplaced" if it remains in its original set of baskets and could not be part of a valid swap to help equalize the sets.

Solution Approach:

The core idea is to first simplify the problem by removing fruits that are already common to both sets. Then, for the remaining fruits, we greedily find the maximum number of swaps possible.

Count and Cancel Common Fruits: 
We begin by creating frequency maps for both fruits1 and fruits2. 
A TreeMap is used to automatically keep the fruits sorted by value, which is essential for the next step. We then iterate through one map and "cancel out" any fruits that are common to both, reducing their counts accordingly.

Identify Remaining Fruits: 
After the cancellation, the maps contain only the fruits that are unique to each original set. 
We flatten these maps into two sorted lists, rem1 and rem2.

Maximize Swaps with a Greedy Two-Pointer Approach: 
Now, we need to find the maximum number of valid swaps between rem1 and rem2. 
Since both lists are sorted, we can do this efficiently using a two-pointer technique.
Initialize two pointers, p1 for rem1 and p2 for rem2, both starting at index 0.

We iterate while both pointers are within their list's bounds:

If rem1[p1] <= rem2[p2]: 
A valid swap is possible! This means rem1[p1] can be "placed" by swapping with rem2[p2].
 We count this as one successful swap and advance both pointers (p1++, p2++) to find the next match.

If rem1[p1] > rem2[p2]: 
The fruit rem2[p2] is too small to be a swap partner for rem1[p1] (or any subsequent, larger fruits in rem1). We discard rem2[p2] as a potential partner and advance only p2++ to check the next fruit in rem2.

Calculate the Final Result: 
The number of successful swaps represents the number of fruits from each list that could be paired up. The unplaced fruits are those left over in each list that couldn't find a partner.
Unplaced in rem1 = rem1.size() - swaps
Unplaced in rem2 = rem2.size() - swaps
Total Unplaced = (rem1.size() - swaps) + (rem2.size() - swaps)

Here's the code:

import java.util.*;
public class Solution {
    private int[] segTree;
    private int n;

    public int numOfUnplacedFruits(int[] fruits, int[] baskets) {
        n = baskets.length;
        // Segment tree size: 4*n is safe
        segTree = new int[4 * n];
        build(baskets, 0, n - 1, 1);

        int unplaced = 0;
        for (int fruit : fruits) {
            if (findAndUse(fruit, 0, n - 1, 1) == -1) {
                unplaced++;
            }
        }
        return unplaced;
    }

    // Build max‐segment‐tree over baskets[low..high], at node idx
    private void build(int[] baskets, int low, int high, int idx) {
        if (low == high) {
            segTree[idx] = baskets[low];
        } else {
            int mid = low + (high - low) / 2;
            build(baskets, low, mid, 2 * idx);
            build(baskets, mid + 1, high, 2 * idx + 1);
            segTree[idx] = Math.max(segTree[2 * idx], segTree[2 * idx + 1]);
        }
    }

    // Find leftmost position in [low..high] with segTree value ≥ fruit,
    // set it to –1, and update tree; return 1 if found, else –1
    private int findAndUse(int fruit, int low, int high, int idx) {
        if (segTree[idx] < fruit) {
            return -1;
        }
        if (low == high) {
            // Leaf: use this basket
            segTree[idx] = -1;
            return 1;
        }
        int mid = low + (high - low) / 2;
        int res;
        if (segTree[2 * idx] >= fruit) {
            res = findAndUse(fruit, low, mid, 2 * idx);
        } else {
            res = findAndUse(fruit, mid + 1, high, 2 * idx + 1);
        }
        // Update current node after child change
        segTree[idx] = Math.max(segTree[2 * idx], segTree[2 * idx + 1]);
        return res;
    }

    // Example usage
    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] fruits = {2, 3, 5, 1};
        int[] baskets = {3, 1, 4, 2};
        int result = sol.numOfUnplacedFruits(fruits, baskets);
        System.out.println("Unplaced fruits: " + result);
    }
}

Complexity:

Time Complexity: O(NlogN+MlogM)
Space Complexity: O(N+M)
