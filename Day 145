Day 145/150:  Max Partitions After Operations

Problem Statement #3003

Problem Statement Explanation:

You are given a string s consisting of lowercase English letters and an integer k. 
You can change at most one character in s to any other lowercase English letter.
A partition of s is defined as a contiguous substring such that the number of distinct characters in that substring does not exceed k.
Your task is to determine the maximum number of partitions you can obtain after performing at most one character modification in the string s.

Input:
s = "accca", k = 2
Output:
3

Explanation:
By changing the middle 'c' to 'b', we get "acbca", which can be split into ["a", "cb", "ca"] — 3 valid partitions.

Solution Approach:

Base Calculation:
Compute the number of partitions in the original string using a helper method (calculatePartitions), which uses a bitmask to track distinct letters in each partition.
Start a new partition whenever adding a new character would exceed k distinct characters.

Character Replacement Simulation:
For every index i in the string:
Try replacing s[i] with each possible letter 'a' to 'z' (except the original one).
For each replacement, recompute the total number of partitions.
Keep track of the maximum number of partitions seen across all possible replacements.

Result:
Return the maximum partitions obtained among all trials (including no change).

Here's the code:

class Solution {

    public int maxPartitionsAfterOperations(String s, int k) {
        int n = s.length();
        int[][] left = new int[n][3];
        int[][] right = new int[n][3];
        int partitions = 0;
        int mask = 0;    
        int distinct = 0; 

        for (int i = 0; i < n - 1; i++) {
            int bit = 1 << (s.charAt(i) - 'a');
            if ((mask & bit) == 0) {
                distinct++;
                if (distinct <= k) {
                    mask |= bit;
                } else {
                    partitions++;
                    mask = bit;
                    distinct = 1;
                }
            }
            left[i + 1][0] = partitions;
            left[i + 1][1] = mask;
            left[i + 1][2] = distinct;
        }

        partitions = 0;
        mask = 0;
        distinct = 0;

        for (int i = n - 1; i > 0; i--) {
            int bit = 1 << (s.charAt(i) - 'a');
            if ((mask & bit) == 0) {
                distinct++;
                if (distinct <= k) {
                    mask |= bit;
                } else {
                    partitions++;
                    mask = bit;
                    distinct = 1;
                }
            }
            right[i - 1][0] = partitions;
            right[i - 1][1] = mask;
            right[i - 1][2] = distinct;
        }

        int maxPartitions = 0;

        for (int i = 0; i < n; i++) {

            int total = left[i][0] + right[i][0] + 2;

            int combinedMask = left[i][1] | right[i][1];
            int combinedDistinct = Integer.bitCount(combinedMask);

            if (left[i][2] == k && right[i][2] == k && combinedDistinct < 26) {
                total++;
            } else if (Math.min(combinedDistinct + 1, 26) <= k) {
                total--;
            }

            maxPartitions = Math.max(maxPartitions, total);
        }

        return maxPartitions;
    }
}

Complexity:

Time Complexity: O(26 * n²)
Space Complexity: O(1)



