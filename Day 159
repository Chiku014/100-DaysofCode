Day 159/200: The Two Sneaky Numbers of Digitville

Problem Statement #3289

Problem Statement Explanation:

In the town of Digitville, there was a list of numbers called nums containing integers from 0 to n - 1. 
Each number was supposed to appear exactly once in the list, however, two mischievous numbers sneaked in an additional time, making the list longer than usual. 
As the town detective, your task is to find these two sneaky numbers.
Return an array of size two containing the two numbers (in any order), so peace can return to Digitville.

Example 1:
Input: nums = [0,1,1,0]
Output: [0,1]
Explanation: The numbers 0 and 1 each appear twice in the array.

Example 2:
Input: nums = [0,3,2,1,3,2]
Output: [2,3]
Explanation: The numbers 2 and 3 each appear twice in the array.

Constraints:
2 <= n <= 100
nums.length == n + 2
0 <= nums[i] < n
The input is generated such that nums contains exactly two repeated elements.

Solution Approach:

This problem can be solved efficiently using a frequency array (also known as a counting array).

Analyze Constraints: The problem states that n <= 100 and all numbers in the input array will be in the range [0, n-1]. 
This means the maximum possible number we can encounter is 99.
Initialize Counter: We can create an integer array, let's call it counts, of size 100. 
This array will act as a hash map, where the index of the array corresponds to a number from the input, and the value at that index stores how many times we've seen that number.
Initialize Result: Create a result array of size 2, int[] result = new int[2], to store the two duplicates we find.
Iterate and Count: We perform a single pass over the input nums array. For each num:
We increment its corresponding counter: counts[num]++.
We immediately check if this new count is equal to 2: if (counts[num] == 2).
If the count is 2, it means this is the first time we've confirmed this number is a duplicate. We add it to our result array.
Optimization: Since we know there are exactly two duplicates, we can stop iterating as soon as we have found both of them (i.e., when our result array is full).
Return: After the loop, the result array will contain the two sneaky numbers.
This approach is extremely fast because array index access and incrementing are O(1) operations.

Here's the code:

class Solution {
    public int[] getSneakyNumbers(int[] nums) {
        int[] counts = new int[100];
        int[] result = new int[2];
        int resultIndex = 0;
        
        for (int num : nums) {
            counts[num]++;
            
            if (counts[num] == 2) {
                result[resultIndex] = num;
                resultIndex++;
                
                if (resultIndex == 2) {
                    break;
                }
            }
        }
        
        return result;
    }
}

Complexity:

Time Complexity: O(N)
Space Complexity: O(1)






