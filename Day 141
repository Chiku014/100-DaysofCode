Day 141/150:  Find Resultant Array After Removing Anagrams

Problem Statement #2273

Problem Statement Explanation:

The problem requires us to process an array of strings called words. 
We need to iterate through the array and remove any string that is an anagram of the string immediately before it. 
This process should be repeated until no more removals can be made.

An anagram is a word formed by rearranging the letters of another word. For example, "listen" is an anagram of "silent".

Example:
Given the input words = ["abba", "baba", "bbaa", "cd", "cd"]:
Compare "baba" with "abba". They are anagrams. Remove "baba". The array becomes ["abba", "bbaa", "cd", "cd"].
Now, compare "bbaa" with "abba". They are also anagrams. Remove "bbaa". The array becomes ["abba", "cd", "cd"].
Compare "cd" with "abba". They are not anagrams. Keep "cd". The array is still ["abba", "cd", "cd"].
Compare the second "cd" with the first "cd". They are anagrams. Remove the second "cd". The array becomes ["abba", "cd"].
No more removals are possible. The final result is ["abba", "cd"].

Solution Approach:

The core of the problem is to efficiently check if two words are anagrams. 
The simplest way to do this is to create a unique "signature" for each word. 
If two words have the same signature, they are anagrams. 
A reliable signature can be created by sorting the characters of the string alphabetically.

For example:
"abba" -> sorted -> "aabb"
"baba" -> sorted -> "aabb"

Since their sorted forms are identical, they are anagrams.

Our algorithm iterates through the input array just once, keeping track of the signature of the last word that was added to our result list.

Algorithm Steps:
Initialize an empty list, result, to store the final output.
Initialize a string, prevSorted, to hold the signature of the last valid word. We can start it as an empty string to ensure the first word is always added.
Iterate through each word in the input words array.
For the current word, calculate its signature by converting it to a character array and sorting it. Let's call this currentSorted.
Compare currentSorted with prevSorted.
If they are not equal, it means the current word is not an anagram of the previous one. We add the original word to our result list and update prevSorted = currentSorted.
If they are equal, we do nothing and move to the next word, effectively removing the current anagram.

Here's the code:

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class Solution {
    public List<String> removeAnagrams(String[] words) {
        List<String> result = new ArrayList<>();
        String prevSorted = "";

        for (String word : words) {
            char[] charArray = word.toCharArray();
            Arrays.sort(charArray);
            String currentSorted = new String(charArray);

            if (!currentSorted.equals(prevSorted)) {
                result.add(word);
                prevSorted = currentSorted;
            }
        }

        return result;
    }
}

Complexity:

Time Complexity: O(Nâ‹…KlogK)
Space Complexity: O(K)






After the loop finishes, return the result list.
