Day 87/100: Count Square Submatrices with All Ones

Problem Statement #1277

Problem Statement Explanation:

Imagine you have a grid where some cells are filled (represented by 1) and some are empty (represented by 0). 
Your goal is to find and count every possible square that is made up entirely of filled cells.
A "square submatrix with all ones" is simply a square-shaped block of cells within the larger grid that contains no zeros. 
These squares can be of different sizes (1x1, 2x2, 3x3, etc.) and they can overlap with each other.
Let's break down an example to make this crystal clear.

Solution Approach:

This problem can be solved efficiently using dynamic programming. 
The core idea is to reuse the input matrix itself as our DP table, where each cell matrix[i][j] will store the side length of the largest square of ones ending at that position.

We iterate through the matrix, and for each cell (i, j) containing a 1, we update its value based on its neighbors:
A square of side k > 1 ending at (i, j) can only exist if there are also squares of side k-1 ending at the cells immediately to its top, left, and top-left.

This gives us the recurrence relation:
matrix[i][j] = 1 + min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1])
The crucial insight is that the updated value in matrix[i][j] also directly represents the number of squares that have (i, j) as their bottom-right corner. 
For example, a value of 3 implies that a 1x1, a 2x2, and a 3x3 square all end at this cell.
Therefore, the total count is simply the sum of all the values in the modified matrix.

Here's the code:

class Solution {
    public int countSquares(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int rows = matrix.length;
        int cols = matrix[0].length;
        int count = 0;

…        return count;
    }
}

Complexity:

Time Complexity: O(m×n)
Space Complexity: O(1)


