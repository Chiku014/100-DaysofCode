Day 135/150: Avoid Flood in The City

Problem Statement #1488

Problem Statement Explanation:

You are given an integer array rains of length n. rains[i] > 0 means on day i it rains on the lake with that number. rains[i] == 0 means on day i there is no rain, and you can choose one lake to dry up.
Your goal is to return an array ans of the same length as rains, where:
ans[i] = -1 if rains[i] > 0.
ans[i] is the lake you choose to dry on day i if rains[i] == 0.
A flood occurs if it rains on a lake that is already full of water. 
If you can successfully avoid all floods, return the ans array. Otherwise, return an empty array.

Solution Approach:

The problem requires us to make strategic decisions on dry days to prevent future floods. 
A greedy approach is effective here: when a lake is about to flood, we should use the earliest possible dry day that occurred after the lake was last filled. 
This strategy saves later dry days for future potential floods, maximizing our chances of success.

To implement this, we need two key data structures:
A HashMap<Integer, Integer> named fullLakes: This map stores which lakes are currently full. 
The key is the lake number, and the value is the day it last rained.
A TreeSet<Integer> named dryDays: This sorted set stores the indices of all available dry days. 
A TreeSet is perfect because it automatically keeps the days sorted and provides an efficient way (higher() method) to find the smallest element greater than a given value.

Algorithm Steps:
Iterate through the rains array from day i = 0 to n-1.
If it's a dry day (rains[i] == 0):
Add the current day i to our dryDays TreeSet.
We can tentatively set ans[i] = 1, as we must dry some lake. 
This value can be overwritten later if this day is needed to prevent a specific flood.

If it's a rainy day (rains[i] > 0):
Set ans[i] = -1.
Check the fullLakes map to see if the lake rains[i] is already full.

If it is, we have a potential flood! Let's say it last rained on lastRainyDay. 
We must find a dry day between lastRainyDay and the current day i.
We query our dryDays TreeSet for dryDays.higher(lastRainyDay). 
This finds the earliest available dry day after the lake was filled.
If no such day exists (higher() returns null), a flood is unavoidable. 
Return an empty array [].
If we find a dryDayToUse, we set ans[dryDayToUse] = rains[i] and remove it from dryDays since it has now been used.
Finally, update the fullLakes map to record that lake rains[i] is now full as of the current day i.
After the loop completes, if we never returned an empty array, it means we successfully avoided all floods. 
The ans array now holds the correct sequence of actions.

Here's the code:

import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

class Solution {
    public int[] avoidFlood(int[] rains) {
        int n = rains.length;
        int[] ans = new int[n];
        
        Map<Integer, Integer> fullLakes = new HashMap<>();
        TreeSet<Integer> dryDays = new TreeSet<>();

        for (int i = 0; i < n; i++) {
            int lake = rains[i];

            if (lake == 0) {
                dryDays.add(i);
                ans[i] = 1; 
            } else {
                ans[i] = -1;
                
                if (fullLakes.containsKey(lake)) {
                    int lastRainyDay = fullLakes.get(lake);
                    
                    Integer dryDayToUse = dryDays.higher(lastRainyDay);
                    
                    if (dryDayToUse == null) {
                        return new int[0];
                    }
                    
                    ans[dryDayToUse] = lake;
                    dryDays.remove(dryDayToUse);
                }
                
                fullLakes.put(lake, i);
            }
        }
        
        return ans;
    }
}

Complexity:

Time Complexity: O(NlogN)
Space Complexity: O(N)




