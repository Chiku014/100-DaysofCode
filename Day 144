Day 144/150: Smallest Missing Non-negative Integer After Operations

Problem Statement #2598

Problem Statement Explanation:

You are given an integer array nums and an integer value.
In one operation, you can add or subtract value from any element of nums.

Return the smallest non-negative integer that cannot be represented as any element in nums after performing any number of such operations.

Example:
Input:
nums = [1, -10, 7, 13, 6, 8], value = 5
Output:
4

Explanation:
After converting each number modulo value, the array becomes {1, 0, 2, 3, 1, 3}.
From these remainders, all integers 0, 1, 2, 3 can be represented, but 4 cannot — so the answer is 4.

Solution Approach:

Since you can add or subtract value infinitely, only the remainder modulo value matters.
Compute the non-negative remainder for each number and count its frequency.
Starting from i = 0, check which integer cannot be formed:
For each i, determine its remainder i % value.
If that remainder’s count is zero, then i cannot be represented — return it.
Otherwise, reduce the count and move to the next i.
This ensures we find the smallest missing non-negative integer efficiently.

Here's the code:

class Solution {
    public int findSmallestInteger(int[] nums, int value) {
        int[] count = new int[value];

        for (int num : nums) {
            int mod = ((num % value) + value) % value; // handle negatives
            count[mod]++;
        }

        int i = 0;
        while (true) {
            int mod = i % value;
            if (count[mod] == 0) {
                return i;
            }
            count[mod]--;
            i++;
        }
    }
}

Complexity:

Time Complexity: O(n + ans)
Space Complexity: O(value)






