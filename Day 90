Day 90/100: Find the Minimum Area to Cover All Ones II

Problem Statement #3197

Problem Statement Explanation:

You are given a 2D binary grid containing 0s and 1s. 
Your task is to find three non-overlapping rectangles that collectively cover all the 1s in the grid. 
The goal is to find a configuration of three such rectangles where the sum of their areas is minimized.

Solution Approach:

Find the Minimum Area to Cover All Ones II
Problem Statement Explanation
You are given a 2D binary grid containing 0s and 1s. Your task is to find three non-overlapping rectangles that collectively cover all the 1s in the grid. The goal is to find a configuration of three such rectangles where the sum of their areas is minimized.

Solution Approach
The core of the problem is to find the optimal way to partition the set of all 1s into three groups. For each group, we can then find its minimum bounding rectangle. The sum of the areas of these three rectangles gives us a candidate for the answer. We need to find the partition that results in the minimum total area.

An exhaustive search of all possible partitions would be too slow. However, the optimal solution for three non-overlapping rectangles can always be formed by making two straight-line cuts on the grid. This insight simplifies the problem into checking a limited set of geometric configurations.

These two cuts can be arranged in two fundamental ways:

1. Two Parallel Cuts
This creates three parallel rectangular strips. We need to check both horizontal and vertical orientations.
Three Horizontal Strips: We can make two horizontal cuts at rows i and j. This divides the grid into three regions:
Rows 0 to i-1
Rows i to j-1
Rows j to m-1

Three Vertical Strips: Similarly, two vertical cuts at columns i and j divide the grid into three vertical regions.
We iterate through all valid pairs of (i, j) for both cases, calculate the total area, and update our minimum.

2. Two Perpendicular Cuts
One horizontal cut and one vertical cut divide the grid into four quadrants. 
To form three rectangles, one rectangle must span two adjacent quadrants, while the other two rectangles cover the remaining individual quadrants. 
This results in four distinct patterns:
One Top, Two Bottom: A horizontal cut separates a single top rectangle from two smaller rectangles in the bottom half (which are separated by a vertical cut).

One Bottom, Two Top: The inverse of the above.
One Left, Two Right: A vertical cut separates a single left rectangle from two smaller rectangles in the right half (which are separated by a horizontal cut).
One Right, Two Left: The inverse of the above.
By iterating through all possible cut positions for these six configurations, we can guarantee that we will find the global minimum area.

Optimization:
To avoid re-scanning the grid for 1s for every single partition, we can pre-process the grid once to create a list of coordinates for all 1s. 
The helper function that calculates the bounding box area for a sub-region can then iterate over this much smaller list (k elements) instead of the subgrid (m*n elements), providing a significant speed-up.

Here;s the code:

import java.util.ArrayList;
import java.util.List;

class Solution {
    public int minimumSum(int[][] grid) { // Method name changed here
        int m = grid.length;
        int n = grid[0].length;

        List<int[]> ones = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    ones.add(new int[]{i, j});
                }
            }
        }
        
        if (ones.isEmpty()) {
            return 0;
        }

        long minTotalArea = Long.MAX_VALUE;

        // Case 1: Three horizontal strips
        for (int i = 1; i < m; i++) {
            for (int j = i + 1; j < m; j++) {
                long area1 = getMinArea(ones, 0, 0, i - 1, n - 1);
                long area2 = getMinArea(ones, i, 0, j - 1, n - 1);
                long area3 = getMinArea(ones, j, 0, m - 1, n - 1);
                if (area1 > 0 && area2 > 0 && area3 > 0) {
                    minTotalArea = Math.min(minTotalArea, area1 + area2 + area3);
                }
            }
        }

        // Case 2: Three vertical strips
        for (int i = 1; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                long area1 = getMinArea(ones, 0, 0, m - 1, i - 1);
                long area2 = getMinArea(ones, 0, i, m - 1, j - 1);
                long area3 = getMinArea(ones, 0, j, m - 1, n - 1);
                if (area1 > 0 && area2 > 0 && area3 > 0) {
                    minTotalArea = Math.min(minTotalArea, area1 + area2 + area3);
                }
            }
        }

        // Case 3: Mixed cuts
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                long a1, a2, a3;

                a1 = getMinArea(ones, 0, 0, i - 1, n - 1);
                a2 = getMinArea(ones, i, 0, m - 1, j - 1);
                a3 = getMinArea(ones, i, j, m - 1, n - 1);
                if (a1 > 0 && a2 > 0 && a3 > 0) minTotalArea = Math.min(minTotalArea, a1 + a2 + a3);

                a1 = getMinArea(ones, i, 0, m - 1, n - 1);
                a2 = getMinArea(ones, 0, 0, i - 1, j - 1);
                a3 = getMinArea(ones, 0, j, i - 1, n - 1);
                if (a1 > 0 && a2 > 0 && a3 > 0) minTotalArea = Math.min(minTotalArea, a1 + a2 + a3);

                a1 = getMinArea(ones, 0, 0, m - 1, j - 1);
                a2 = getMinArea(ones, 0, j, i - 1, n - 1);
                a3 = getMinArea(ones, i, j, m - 1, n - 1);
                if (a1 > 0 && a2 > 0 && a3 > 0) minTotalArea = Math.min(minTotalArea, a1 + a2 + a3);

                a1 = getMinArea(ones, 0, j, m - 1, n - 1);
                a2 = getMinArea(ones, 0, 0, i - 1, j - 1);
                a3 = getMinArea(ones, i, 0, m - 1, j - 1);
                if (a1 > 0 && a2 > 0 && a3 > 0) minTotalArea = Math.min(minTotalArea, a1 + a2 + a3);
            }
        }

        return (int) minTotalArea;
    }

    private long getMinArea(List<int[]> ones, int r1, int c1, int r2, int c2) {
        int minR = Integer.MAX_VALUE, maxR = -1;
        int minC = Integer.MAX_VALUE, maxC = -1;

        for (int[] point : ones) {
            int r = point[0];
            int c = point[1];
            if (r >= r1 && r <= r2 && c >= c1 && c <= c2) {
                minR = Math.min(minR, r);
                maxR = Math.max(maxR, r);
                minC = Math.min(minC, c);
                maxC = Math.max(maxC, c);
            }
        }

        if (maxR == -1) {
            return 0;
        }

        return (long) (maxR - minR + 1) * (maxC - minC + 1);
    }
}

Complexity:

Time Complexity: O(n)
Space Complexity: O(n)

